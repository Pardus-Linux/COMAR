#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2005, TUBITAK/UEKAE
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version. Please read the COPYING file.
#

import os
import array
import fcntl
import struct
import socket
import csapi

class ifconfig:
    """ ioctl stuff """

    IFNAMSIZ = 16               # interface name size

    # From <bits/ioctls.h>

    SIOCGIFADDR = 0x8915        # get PA address
    SIOCGIFBRDADDR  = 0x8919    # get broadcast PA address
    SIOCGIFCONF = 0x8912        # get iface list
    SIOCGIFFLAGS = 0x8913       # get flags
    SIOCGIFMTU = 0x8921         # get MTU size
    SIOCGIFNETMASK  = 0x891b    # get network PA mask
    SIOCSIFADDR = 0x8916        # set PA address
    SIOCSIFBRDADDR  = 0x891a    # set broadcast PA address
    SIOCSIFFLAGS = 0x8914       # set flags
    SIOCSIFMTU = 0x8922         # set MTU size
    SIOCSIFNETMASK  = 0x891c    # set network PA mask

    # From <net/if.h>    

    IFF_UP = 0x1           # Interface is up.
    IFF_BROADCAST = 0x2    # Broadcast address valid.
    IFF_DEBUG = 0x4        # Turn on debugging.
    IFF_LOOPBACK = 0x8     # Is a loopback net.
    IFF_POINTOPOINT = 0x10 # Interface is point-to-point link.
    IFF_NOTRAILERS = 0x20  # Avoid use of trailers.
    IFF_RUNNING = 0x40     # Resources allocated.
    IFF_NOARP = 0x80       # No address resolution protocol.
    IFF_PROMISC = 0x100    # Receive all packets.
    IFF_ALLMULTI = 0x200   # Receive all multicast packets.
    IFF_MASTER = 0x400     # Master of a load balancer.
    IFF_SLAVE = 0x800      # Slave of a load balancer.
    IFF_MULTICAST = 0x1000 # Supports multicast.
    IFF_PORTSEL = 0x2000   # Can set media type.
    IFF_AUTOMEDIA = 0x4000 # Auto media select active.


    def __init__(self):
        # create a socket to communicate with system
        self.sockfd = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

    def _ioctl(self, func, args):
        return fcntl.ioctl(self.sockfd.fileno(), func, args)

    def _call(self, ifname, func, ip = None):

        if ip is None:
            data = (ifname + '\0'*32)[:32]
        else:
            ifreq = (ifname + '\0' * self.IFNAMSIZ)[:self.IFNAMSIZ]
            data = struct.pack("16si4s10x", ifreq, socket.AF_INET, socket.inet_aton(ip))

        try:
            result = self._ioctl(func, data)
        except IOError:
            return None

        return result

    def _readsys(self, ifname, f):
        try:
            fp = file(os.path.join("/sys/class/net", ifname, f))
            result = fp.readline().rstrip('\n')
            fp.close()
        except IOError:
            return None
            
        return result

    def getInterfaceList(self):
        """ Get all interface names in a list """
        # get interface list
        buffer = array.array('c', '\0' * 1024)
        ifconf = struct.pack("iP", buffer.buffer_info()[1], buffer.buffer_info()[0])
        result = self._ioctl(self.SIOCGIFCONF, ifconf)

        # loop over interface names
        iflist = []
        size, ptr = struct.unpack("iP", result)
        for idx in range(0, size, 32):
            ifconf = buffer.tostring()[idx:idx+32]
            name, dummy = struct.unpack("16s16s", ifconf)
            name, dummy = name.split('\0', 1)
            iflist.append(name)

        return iflist

    def getAddr(self, ifname):
        """ Get the inet addr for an interface """
        result = self._call(ifname, self.SIOCGIFADDR)
        return socket.inet_ntoa(result[20:24])

    def getNetmask(self, ifname):
        """ Get the netmask for an interface """
        result = self._call(ifname, self.SIOCGIFNETMASK)
        return socket.inet_ntoa(result[20:24])

    def getBroadcast(self, ifname):
        """ Get the broadcast addr for an interface """
        result = self._call(ifname, self.SIOCGIFBRDADDR)
        return socket.inet_ntoa(result[20:24])

    def getStatus(self, ifname):
        """ Check whether interface is UP """
        result = self._call(ifname, self.SIOCGIFFLAGS)
        flags, = struct.unpack('H', result[16:18])
        return (flags & self.IFF_UP) != 0

    def getMTU(self, ifname):
        """ Get the MTU size of an interface """
        data = self._call(ifname, self.SIOCGIFMTU)
        mtu = struct.unpack("16si12x", data)[1]
        return mtu

    def getMAC(self, ifname):
        """ Get MAC address of an interface """
        mac = self._readsys(ifname, "address")
        return mac

    def getRX(self, ifname):
        """ Get received bytes of an interface """
        rx = self._readsys(ifname, "statistics/rx_bytes")
        return int(rx)

    def getTX(self, ifname):
        """ Get transferred bytes of an interface """
        tx = self._readsys(ifname, "statistics/tx_bytes")
        return int(tx)

    def setAddr(self, ifname, ip):
        """ Set the inet addr for an interface """
        result = self._call(ifname, self.SIOCSIFADDR, ip)

        if socket.inet_ntoa(result[20:24]) is ip:
            return True
        else:
            return None

    def setNetmask(self, ifname, ip):
        """ Set the netmask for an interface """
        result = self._call(ifname, self.SIOCSIFNETMASK, ip)

        if socket.inet_ntoa(result[20:24]) is ip:
            return True
        else:
            return None

    def setBroadcast(self, ifname, ip):
        """ Set the broadcast addr for an interface """
        result = self._call(ifname, self.SIOCSIFBRDADDR, ip)

        if socket.inet_ntoa(result[20:24]) is ip:
            return True
        else:
            return None

    def setStatus(self, ifname, status):
        """ Set interface status (UP/DOWN) """
        ifreq = (ifname + '\0' * self.IFNAMSIZ)[:self.IFNAMSIZ]

        if status is "UP":
            flags = self.IFF_UP
            flags |= self.IFF_RUNNING
            flags |= self.IFF_BROADCAST
            flags |= self.IFF_MULTICAST
            flags &= ~self.IFF_NOARP
            flags &= ~self.IFF_PROMISC
        elif status is "DOWN":
            flags = ~self.IFF_UP
        else:
            return None

        data = struct.pack("16sh", ifreq, flags)
        result = self._ioctl(self.SIOCSIFFLAGS, data)
        return result

    def setMTU(self, ifname, mtu):
        """ Set the MTU size of an interface """
        ifreq = (ifname + '\0' * self.IFNAMSIZ)[:self.IFNAMSIZ]

        data = struct.pack("16si", ifreq, mtu)
        result = self._ioctl(self.SIOCSIFMTU, data)

        if struct.unpack("16si", result)[1] is mtu:
            return True
        else:
            return None


class Route:
    """ ioctl stuff """

    # From <bits/ioctls.h>

    SIOCADDRT = 0x890B      # add routing table entry
    SIOCDELRT = 0x890C      # delete routing table entry
    SIOCRTMSG = 0x890D      # call to routing system
    INADDR_ANY = '\0' * 4   # Any Internet Address

    def delRoute(self, gw, dst = "0.0.0.0", mask = "0.0.0.0"):
        """ Delete a route entry from kernel routing table """
        try:
            csapi.changeroute(self.SIOCDELRT, gw, dst, mask)
        except:
            pass

    def delDefaultRoute(self):
        """ Delete the default gw, which is a route entry with gateway to Any Internet Address """
        self.delRoute("0.0.0.0")

    def setDefaultRoute(self, gw, dst = "0.0.0.0", mask = "0.0.0.0"):
        """ Set the default gateway. To do this we must delete the previous default gateway
            and the route entry set for gw, if any, or we will end up with multiple entries """

        self.delDefaultRoute()
        self.delRoute(gw)
        try:
            csapi.changeroute(self.SIOCADDRT, gw, dst, mask)
        except:
            pass


def sysValue(path, dir, file_):
    f = file(os.path.join(path, dir, file_))
    data = f.read().rstrip('\n')
    f.close()
    return data

def queryPCI(vendor, device):
    # dependency to pciutils!
    f = file("/usr/share/misc/pci.ids")
    flag = 0
    company = ""
    for line in f.readlines():
        if flag == 0:
            if line.startswith(vendor):
                flag = 1
                company = line[5:].strip()
        else:
            if line.startswith("\t"):
                if line.startswith("\t" + device):
                    return (company, line[6:].strip())
            elif not line.startswith("#"):
                flag = 0
    return ("Unknown", "Unknown")

# Internal functions

ARPHRD_ETHER = 1
sysfs_path = "/sys/class/net"

def _device_uid(dev):
    vendor = sysValue(sysfs_path, dev, "device/vendor").lstrip('0x')
    device = sysValue(sysfs_path, dev, "device/device").lstrip('0x')
    return "pci:%s_%s_%s" % (vendor, device, dev)

def _device_check(dev, uid):
    dev_uid = _device_uid(dev)
    t1 = uid.rsplit("_", 1)
    t2 = uid.rsplit("_", 1)
    return t1[0] == t2[0]

def _device_dev(uid):
    t = uid.rsplit("_", 1)
    if _device_check(t[1], uid):
        return t[1]
    iflist = []
    for iface in os.listdir(sysfs_path):
        if csapi.atoi(sysValue(sysfs_path, iface, "type")) == ARPHRD_ETHER:
            iflist.append(_device_uid(iface))
    for dev in iflist:
        if _device_check(dev, uid):
            return dev
    return None

def _device_info(uid):
    t = uid.split(':', 1)
    if len(t) < 2:
        return "Unknown (%s)" % uid
    vendor, device, dev = t[1].split('_')
    name = queryPCI(vendor, device)
    return "%s (%s:%s) %s" % (name[1], vendor, device, name[0])

def _get(dict, key, default):
    val = default
    if dict and dict.has_key(key):
        val = dict[key]
    return val

class Dev:
    def __init__(self, name):
        dict = get_instance("name", name)
        self.uid = _get(dict, "device", None)
        self.name = name
        self.dev = None
        if self.uid:
            self.dev = _device_dev(self.uid)
        self.state = _get(dict, "state", "down")
        self.mode = _get(dict, "mode", "auto")
        self.address = _get(dict, "address", None)
        self.gateway = _get(dict, "gateway", None)
        self.mask = _get(dict, "mask", None)
    
    def up(self):
        ifc = ifconfig()
        if self.address:
            ifc.setAddr(self.dev, self.address)
        if self.gateway:
            route = Route()
            route.setDefaultRoute(self.gateway)
        ifc.setStatus(self.dev, "UP")
        notify("Net.Link.stateChanged", self.name + "\nup")
    
    def down(self):
        ifc = ifconfig()
        ifc.setStatus(self.dev, "DOWN")
        notify("Net.Link.stateChanged", self.name + "\ndown")


# Net.Link API

def modes():
    return "device,net,auto"

def linkInfo():
    return "\n".join([
        "net",
        "Ethernet network",
        ""
    ])

def deviceList():
    iflist = []
    for iface in os.listdir(sysfs_path):
        if csapi.atoi(sysValue(sysfs_path, iface, "type")) == ARPHRD_ETHER:
            if not os.path.exists(os.path.join(sysfs_path, iface, "wireless")):
                uid = _device_uid(iface)
                info = _device_info(uid)
                iflist.append("%s %s" % (uid, info))
    return "\n".join(iflist)

def setConnection(name=None, device=None):
    pass

def deleteConnection(name=None):
    pass

def setAddress(name=None, mode=None, address=None, mask=None, gateway=None):
    dev = Dev(name)
    if dev.state == "up":
        dev.address = address
        dev.gateway = gateway
        dev.up()

def setRemote(name=None, remote=None):
    fail("Not supported")

def setState(name=None, state=None):
    dev = Dev(name)
    if state != "up" and state != "down":
        fail("unknown state")
    
    if not dev.dev:
        fail("Device not found")
    
    if state == "up":
        dev.up()
    else:
        dev.down()

def connections():
    list = instances("name")
    if list:
        return "\n".join(list)
    return ""

def connectionInfo(name=None):
    dict = get_instance("name", name)
    if not dict:
        fail("No such connection")
    s = "\n".join([name, dict["device"], _device_info(dict["device"])])
    return s

def getAddress(name=None):
    dict = get_instance("name", name)
    if not dict:
        fail("No such connection")
    if dict["address"] == "auto":
        # FIXME: query interface
        s = "\n".join([name, "fixme"])
    else:
        s = "\n".join([name, dict["address"]])
        if dict.has_key("mask"):
            s += "\n" + dict["mask"]
    return s

def getState(name=None):
    dev = Dev(name)
    if not dev:
        fail("No such connection")
    return name + "\n" + dev.state
